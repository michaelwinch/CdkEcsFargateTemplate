# CDK ECS Fargate Template

This repo is a template to create an ECS Fargate task using CDK. You can just copy this and fill in the missing configurations, or follow the steps below to set it up from scratch.

I recommend setting it up from scratch if this is the first time you're doing this, as you'll learn a lot more about how everything fits together and how to debug it. It should also be a lot more up to date than I'll keep this repo.

## Settings to configure
If you're using this as a template and just want to copy this and get going, you'll want to configure the following:
* Network settings in `network-configuration.json`
* AWS Account details in `package.json`

## Required commands/tools
* `dotnet`
* `aws-cli`
* CDK CLI
    * `npm install -g aws-cdk@latest`
* `docker`
* `yarn` (optional)

## How to set it up from scratch

1. Create your git repo, readme and .gitignore
2. Create a new solution
    1. `dotnet new solution`
3. Create a new tool manifest which will includes any tools which will be used in this solution
    1. `dotnet new tool-manifest`
    2. This generates the file `.config/dotnet-tools.json`
4. Add paket (this is personal preference)
    1. `dotnet tool install paket`
    2. You'll be able to run paket commands like so `dotnet paket install`
5. Add fantomas if wanted (F# formatter)
    1. `dotnet tool install paket`
    2. Create your `.editorconfig` file
6. Add yarn (personal preference for running scripts)
    1. `yarn init`
    2. Delete the contents of the generated `package.json`
    3. Add `private: true`
    4. Add `scripts: {}`
7. Create a project for your app source code
    1. `mkdir src`
    2. `cd src`
    3. `dotnet new console --language f# --framework net8.0 --name App`
    4. `cd ..`
    5. `dotnet sln add src/App/App.fsproj`
8. Create a project for your CDK code
    1. `mkdir cdk`
    2. `cd cdk`
    3. `cdk init app --language fsharp`
    4. `cd ..`
9. We don't need some of what's generated by the cdk template so we can clean that up
    1. `mv cdk/src/Cdk cdk`
    2. `rm -rf cdk/src`
    3. Grab the cdk specific patterns from the generated `.gitignore` and put them in your own one
    4. `rm cdk/.gitignore`
    5. `rm cdk/README.md`
10. Add the projects to your solution
    1. `dotnet sln add src/App/App.fsproj`
    2. `dotnet sln add cdk/Cdk/Cdk.fsproj`

By this point, we have created a new repo and set up the framework of the code we need. This is a good place to push what you've got so far and take a break.

Next, we will create a docker image from your app code and run it locally. It will include scripts that you'll reuse a lot, you can use your preferred method for this but I'm using `yarn` here.

1. Create a `.dockerignore` file
    1. I let Rider generate mine when creating a new solution at one point, and have just been reusing it
2. Create a `Dockerfile`
    1. I let Rider generate this too but I edited it to work with paket insted of nuget
    2. Main changes are copying the tool manifest and paket files, and restoring those before running `dotnet build` and `dotnet publish`
    3. It's worth spending time here to understand the main dockerfile commands by reading the docker documentation
        1. FROM
        2. WORKDIR
        3. COPY
3. Build the docker image
    1. `docker build --platform=linux/amd64 -t cdk_ecs_fargate_app .`
    2. The platform here is needed to run the task on Fargate. You can omit it and it will run locally, and you'll see the error that comes up later on.
4. Run it locally
    1. `docker run cdk_ecs_fargate_app`
    2. You should see the hello world output

Next we'll set up the CDK stack.

1. Add references to the CDK packages
    1. `Amazon.CDK.Lib` NOT `Amazon.CDK`
    2. `Amazon.CDK.AWS.ECS`
    3. `dotnet paket install`
2. Implement the CDK stack
    1. The code is fairly self explanatory, refer to the CDK documentation for details on how to customise things like CPU / memory usage
3. Move customise the `cdk.json` file to support the new file structure
    1. `mv cdk/cdk.json .`
    2. Edit the file, set `app` to the correct file path of the CDK project
4. Deploy the stack
    1. `cdk deploy`
5. Destroy the stack
    1. `cdk destroy`
    2. Useful in case you notice an issue in the stack e.g. wrong name or if the stack is for a one off task

You should now be able to see the new resources in the AWS console. Next we'll push the docker image to the new ECR repo. These commands are available in the AWS console if you select a repo and click on 'View push commands'.

1. Build your docker image like when you run it locally
2. Log in to ECR
    1. `aws ecr get-login-password --region <region> | docker login --username AWS --password-stdin <accountId>.dkr.ecr.<region>.amazonaws.com`
3. Tag the image
    1. `docker tag cdk_ecs_fargate_app:latest <accountId>.dkr.ecr.<region>.amazonaws.com/cdk_ecs_fargate_app:latest`
4. Push it
    1. `docker push <accountId>.dkr.ecr.<region>.amazonaws.com/cdk_ecs_fargate_app:latest`

We should now have a docker image which is hosted in ECR, we just need to run it using ECS.

This will depend on your networking setup. We use a VPC, and set up a new subnet and security group for this task to run in. This subnet will need a NAT.

1. Create a `network-configuration.json` file
    1. Specify the subnet and security group
    2. `assignPublicIp` must be enabled in order to retrieve the image from ECR, as ECR repos live outside the VPC
2. Run the task
    1. `aws ecs run-task --cluster cdk_ecs_fargate_app --task-definition cdk_ecs_fargate_app-td --launch-type FARGATE --count 1 --network-configuration file://network-configuration.json`

Hopefully you should see a stopped task in your ECS cluster in the AWS console, and if you view the logs you should see the hello world response.
